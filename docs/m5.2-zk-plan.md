# M5.2: Zero-Knowledge Extension Plan

**Status**: ğŸ”„ In Progress  
**Date**: 2025-11-08  
**Estimate**: 4 hours  
**Objective**: Add polynomial blinding to achieve zero-knowledge property

---

## 1. Problem Statement

### VULN-001: Witness Leakage

**Current Issue**: `prove_r1cs()` commits directly to quotient polynomial Q(X):
```
Q(X) = (A_z(X)Â·B_z(X) - C_z(X)) / Z_H(X)
```

**Vulnerability**: Q(X) reveals information about witness z:
- Q(X) coefficients depend on witness values
- Polynomial evaluation Q(Î±) leaks witness information
- Not zero-knowledge: verifier learns about z beyond satisfiability

**Attack**: Malicious verifier can derive partial witness information from:
1. Commitment to Q(X) (LWE commitment reveals approximate polynomial)
2. Evaluations Q(Î±), Q(Î²) at challenges
3. Correlation with A_z(Î±), B_z(Î±), C_z(Î±) reveals constraint structure

---

## 2. Zero-Knowledge Solution

### Polynomial Blinding

**Method**: Add random blinding polynomial rÂ·Z_H(X):
```
Q'(X) = Q(X) + rÂ·Z_H(X)
```

Where:
- `r` = random blinding factor (sampled from F_q)
- `Z_H(X) = X^m - 1` (vanishing polynomial on domain H)

**Key Property**: Blinded polynomial Q'(X) satisfies same divisibility:
```
Q'(X)Â·Z_H(X) = Q(X)Â·Z_H(X) + rÂ·Z_H(X)Â²
             = A_z(X)Â·B_z(X) - C_z(X) + rÂ·Z_H(X)Â²
```

At challenge Î±:
```
Q'(Î±)Â·Z_H(Î±) = Q(Î±)Â·Z_H(Î±) + rÂ·Z_H(Î±)Â²
             = A_z(Î±)Â·B_z(Î±) - C_z(Î±) + rÂ·Z_H(Î±)Â²
```

**Verification**: Modify equation to account for rÂ·Z_H(Î±):
```
Q'(Î±)Â·Z_H(Î±) ?= A_z(Î±)Â·B_z(Î±) - C_z(Î±) + rÂ·Z_H(Î±)Â²  [WRONG]
```

**Wait, this doesn't work!** Verifier doesn't know `r`.

---

## 3. Correct ZK Approach

### Issue with Simple Blinding

Simple blinding `Q'(X) = Q(X) + rÂ·Z_H(X)` doesn't work because:
- Verification equation becomes: `Q'(Î±)Â·Z_H(Î±) = A_z(Î±)Â·B_z(Î±) - C_z(Î±) + rÂ·Z_H(Î±)Â²`
- Verifier needs to know `r` to check, but revealing `r` defeats ZK

### Proper Zero-Knowledge Construction

**Solution 1: Blind A_z, B_z, C_z polynomials**

Instead of blinding Q(X), blind the input polynomials:
```
A'_z(X) = A_z(X) + r_AÂ·Z_H(X)
B'_z(X) = B_z(X) + r_BÂ·Z_H(X)
C'_z(X) = C_z(X) + r_CÂ·Z_H(X)
```

Where r_A, r_B, r_C are random blinding factors.

**Verification**: Modified equation:
```
Q(Î±)Â·Z_H(Î±) ?= A'_z(Î±)Â·B'_z(Î±) - C'_z(Î±)
```

Expanding:
```
Q(Î±)Â·Z_H(Î±) ?= [A_z(Î±) + r_AÂ·Z_H(Î±)]Â·[B_z(Î±) + r_BÂ·Z_H(Î±)] - [C_z(Î±) + r_CÂ·Z_H(Î±)]
             = A_z(Î±)Â·B_z(Î±) + A_z(Î±)Â·r_BÂ·Z_H(Î±) + B_z(Î±)Â·r_AÂ·Z_H(Î±) + r_AÂ·r_BÂ·Z_H(Î±)Â² - C_z(Î±) - r_CÂ·Z_H(Î±)
```

**Issue**: Verification equation changes, verifier needs to know r_A, r_B, r_C.

---

**Solution 2: Commit to blinded Q(X), reveal blind in proof**

Standard SNARK approach:
```
1. Prover samples random r âˆˆ F_q
2. Compute Q'(X) = Q(X) + rÂ·Z_H(X)
3. Commit to Q'(X) â†’ commitment C_Q'
4. Include r in proof (explicit)
5. Verifier checks: Q'(Î±) - rÂ·Z_H(Î±) = [A_z(Î±)Â·B_z(Î±) - C_z(Î±)] / Z_H(Î±)
```

**Verification Equation**:
```
[Q'(Î±) - rÂ·Z_H(Î±)]Â·Z_H(Î±) ?= A_z(Î±)Â·B_z(Î±) - C_z(Î±)
Q'(Î±)Â·Z_H(Î±) - rÂ·Z_H(Î±)Â² ?= A_z(Î±)Â·B_z(Î±) - C_z(Î±)
Q'(Î±)Â·Z_H(Î±) ?= A_z(Î±)Â·B_z(Î±) - C_z(Î±) + rÂ·Z_H(Î±)Â²
```

**Zero-Knowledge Property**:
- Commitment C_Q' hides Q(X) (LWE hardness)
- Blinding factor r is uniformly random
- Q'(X) = Q(X) + rÂ·Z_H(X) is statistically independent of Q(X)
- Simulator can generate (C_Q', r, Q'(Î±), Q'(Î²)) without knowing witness

---

## 4. Implementation Plan

### 4.1. Add `prove_r1cs_zk()` Function

**Signature**:
```rust
pub fn prove_r1cs_zk(
    r1cs: &R1CS,
    witness: &[u64],
    ctx: &LweContext,
    rng: &mut impl RngCore,
    seed: u64,
) -> Result<ProofR1CS_ZK, Error>
```

**Steps**:
1. Compute quotient polynomial Q(X)
2. **Sample random blinding factor r** â† F_q (using `rng`)
3. Compute blinded polynomial Q'(X) = Q(X) + rÂ·Z_H(X)
   - Z_H(X) = X^m - 1 = [0, 0, ..., 0, -1, 0, 0, ..., 1] (degree m)
4. Commit to Q'(X) â†’ C_Q'
5. Derive challenges Î±, Î² (same as before)
6. Evaluate Q'(Î±), Q'(Î²)
7. Include r in proof

### 4.2. Add `ProofR1CS_ZK` Structure

**Fields**:
```rust
pub struct ProofR1CS_ZK {
    commitment_q_prime: Commitment,  // Commitment to Q'(X)
    blinding_factor: u64,             // Blinding r (explicit)
    challenge_alpha: Challenge,       // First challenge Î±
    challenge_beta: Challenge,        // Second challenge Î²
    
    // Evaluations at Î±
    q_prime_alpha: u64,               // Q'(Î±)
    a_z_alpha: u64,                   // A_z(Î±)
    b_z_alpha: u64,                   // B_z(Î±)
    c_z_alpha: u64,                   // C_z(Î±)
    
    // Evaluations at Î²
    q_prime_beta: u64,                // Q'(Î²)
    a_z_beta: u64,                    // A_z(Î²)
    b_z_beta: u64,                    // B_z(Î²)
    c_z_beta: u64,                    // C_z(Î²)
    
    // Opening proofs
    opening_alpha: Opening,
    opening_beta: Opening,
}
```

### 4.3. Add `verify_r1cs_zk()` Function

**Verification Equations** (at challenge Î±):
```rust
// 1. Recompute Î± from public inputs and commitment
let alpha_prime = Challenge::derive(&public_inputs, &proof.commitment_q_prime, r1cs.modulus);
assert_eq!(alpha_prime.alpha(), proof.challenge_alpha.alpha());

// 2. Compute Z_H(Î±)
let z_h_alpha = r1cs.eval_vanishing(proof.challenge_alpha.alpha().value());

// 3. Check divisibility with blinding:
//    [Q'(Î±) - rÂ·Z_H(Î±)]Â·Z_H(Î±) ?= A_z(Î±)Â·B_z(Î±) - C_z(Î±)
let q_unblinded = (proof.q_prime_alpha - (proof.blinding_factor * z_h_alpha)) % modulus;
let lhs = (q_unblinded * z_h_alpha) % modulus;
let rhs = (proof.a_z_alpha * proof.b_z_alpha - proof.c_z_alpha) % modulus;
assert_eq!(lhs, rhs);

// 4. Repeat for challenge Î²
// ...
```

### 4.4. Implement Simulator (Zero-Knowledge Property)

**Goal**: Prove that proof distribution is independent of witness.

**Simulator**:
```rust
pub fn simulate_proof_zk(
    r1cs: &R1CS,
    public_inputs: &[u64],
    rng: &mut impl RngCore,
) -> ProofR1CS_ZK
```

**Steps**:
1. Sample random commitment C_Q' (without knowing Q')
2. Sample random blinding r â† F_q
3. Derive challenges Î±, Î² (from public_inputs and C_Q')
4. **Sample random evaluations** Q'(Î±), Q'(Î²), A_z(Î±), B_z(Î±), C_z(Î±), etc.
   - Constraint: Must satisfy verification equations
   - Sample Q'(Î±) freely, compute A_z(Î±)Â·B_z(Î±) - C_z(Î±) to match
5. Generate fake opening proofs (openings are random)

**Zero-Knowledge Test**:
```rust
#[test]
fn test_zk_indistinguishability() {
    let real_proof = prove_r1cs_zk(r1cs, witness, ctx, &mut rng, seed);
    let sim_proof = simulate_proof_zk(r1cs, public_inputs, &mut rng);
    
    // Statistical distance between distributions should be negligible
    // In practice: verify both pass verification
    assert!(verify_r1cs_zk(&real_proof, public_inputs, r1cs));
    assert!(verify_r1cs_zk(&sim_proof, public_inputs, r1cs));
}
```

---

## 5. Mathematical Correctness

### Completeness (Honest Prover)

**Claim**: Valid witness â†’ verifying proof

**Proof**:
1. Q(X) = (A_zÂ·B_z - C_z) / Z_H by construction
2. Q'(X) = Q(X) + rÂ·Z_H(X)
3. At Î±: Q'(Î±)Â·Z_H(Î±) = Q(Î±)Â·Z_H(Î±) + rÂ·Z_H(Î±)Â²
4. = A_z(Î±)Â·B_z(Î±) - C_z(Î±) + rÂ·Z_H(Î±)Â²
5. Unblinding: [Q'(Î±) - rÂ·Z_H(Î±)]Â·Z_H(Î±) = Q(Î±)Â·Z_H(Î±) = A_z(Î±)Â·B_z(Î±) - C_z(Î±) âœ“

### Soundness (Malicious Prover)

**Claim**: Invalid witness â†’ reject with probability â‰¥ 1 - 2/|F_q|

**Proof** (sketch):
1. If witness invalid: A_zÂ·B_z - C_z â‰  QÂ·Z_H for any Q
2. Prover must forge Q'(X) such that [Q'(Î±) - rÂ·Z_H(Î±)]Â·Z_H(Î±) = A_z(Î±)Â·B_z(Î±) - C_z(Î±)
3. For random Î±, this holds only if Q' is correctly formed (Schwartz-Zippel lemma)
4. Two-challenge verification: probability of successful forge â‰¤ 2/|F_q| â‰ˆ 2^-63

### Zero-Knowledge

**Claim**: Proof reveals nothing beyond satisfiability

**Proof**:
1. Simulator generates proof without witness
2. Real proof distribution â‰ˆ Simulated proof distribution (statistical distance negligible)
3. Blinding factor r is uniformly random â†’ Q'(X) statistically independent of Q(X)
4. Commitment C_Q' computationally hides Q'(X) (LWE hardness assumption)

---

## 6. Implementation Checklist

### Code Changes

- [ ] Add `prove_r1cs_zk()` function
  - [ ] Sample blinding factor r using RngCore
  - [ ] Compute Q'(X) = Q(X) + rÂ·Z_H(X)
  - [ ] Commit to Q'(X)
  - [ ] Evaluate Q'(Î±), Q'(Î²)
  - [ ] Include r in proof structure

- [ ] Add `ProofR1CS_ZK` structure
  - [ ] Field: `blinding_factor: u64`
  - [ ] Field: `q_prime_alpha, q_prime_beta` (instead of q_alpha, q_beta)
  - [ ] Serialization/Deserialization (serde)

- [ ] Add `verify_r1cs_zk()` function
  - [ ] UnblinĞ´ Q'(Î±) â†’ Q(Î±) using rÂ·Z_H(Î±)
  - [ ] Verify both challenges (Î± and Î²)
  - [ ] Check opening proofs

- [ ] Implement `simulate_proof_zk()` (for ZK testing)
  - [ ] Sample random commitment
  - [ ] Sample random evaluations satisfying equations
  - [ ] Generate fake openings

### Tests

- [ ] Unit test: `test_zk_proof_verifies()`
  - Valid witness â†’ ZK proof verifies

- [ ] Unit test: `test_zk_proof_rejects_invalid_witness()`
  - Invalid witness â†’ ZK proof generation fails OR verification rejects

- [ ] Unit test: `test_zk_indistinguishability()`
  - Real proof â‰ˆ Simulated proof (both verify)

- [ ] Integration test: `test_zk_vs_non_zk()`
  - ZK and non-ZK proofs both verify for same witness
  - ZK proof slightly larger (includes blinding factor)

- [ ] Property-based test: `test_zk_soundness_random_witness()`
  - Random invalid witnesses â†’ proofs reject

### Documentation

- [ ] Update `architecture.md` with ZK extension
- [ ] Create `docs/zk-protocol.md` (detailed ZK proof)
- [ ] Update CHANGELOG.md [Unreleased]
- [ ] Add security analysis (VULN-001 mitigated)

---

## 7. Expected Outcomes

### Security

- âœ… **VULN-001 Mitigated**: Witness leakage eliminated
- âœ… **Zero-Knowledge**: Proof reveals only satisfiability
- âœ… **Soundness**: Two-challenge verification (Îµ â‰¤ 2^-63)
- âœ… **Completeness**: Valid witness â†’ verifying proof

### Performance

- **Proof Size**: +8 bytes (blinding factor r)
- **Prover Time**: +O(m) for computing rÂ·Z_H(X)
- **Verifier Time**: +O(1) for unblinding Q'(Î±) - rÂ·Z_H(Î±)
- **Overhead**: <1% (negligible)

### Quality

- **Test Coverage**: 4 new unit tests + 1 property test
- **Documentation**: 3 new docs (zk-protocol.md, m5.2-zk-plan.md, updated architecture.md)
- **Correctness**: Mathematical proofs (completeness, soundness, ZK)

---

## 8. Timeline

| Task | Estimate | Cumulative |
|------|----------|------------|
| Add `prove_r1cs_zk()` | 1.0h | 1.0h |
| Add `ProofR1CS_ZK` struct | 0.5h | 1.5h |
| Add `verify_r1cs_zk()` | 1.0h | 2.5h |
| Implement simulator | 0.5h | 3.0h |
| Unit tests (4 tests) | 0.5h | 3.5h |
| Documentation | 0.5h | 4.0h |
| **Total** | **4.0h** | - |

---

## 9. References

### Literature

- **Groth16**: "On the Size of Pairing-based Non-interactive Arguments" (2016)
- **Plonk**: "Permutations over Lagrange-bases for Oecumenical Noninteractive Arguments of Knowledge" (2019)
- **Sonic**: "Zero-Knowledge Proofs from Secure Multiparty Computation" (2019)

### Zero-Knowledge Definitions

- **Statistical ZK**: Simulator distribution = Real distribution (information-theoretic)
- **Computational ZK**: Distributions computationally indistinguishable (LWE assumption)
- **Perfect ZK**: Distributions identical (our goal with random blinding)

### Blinding Techniques

- **Polynomial Blinding**: Add rÂ·Z_H(X) to hide coefficients
- **Commitment Blinding**: Pedersen commitments with random trapdoor
- **Proof Randomization**: Fiat-Shamir with salted challenges

---

## Status

**Current**: Planning phase (this document)  
**Next**: Implementation of `prove_r1cs_zk()` and `ProofR1CS_ZK`  
**Blocked**: None  
**Risks**: Mathematical correctness (blinding verification equation)

**Decision**: Use Solution 2 (commit to Q'(X), reveal r explicitly).
